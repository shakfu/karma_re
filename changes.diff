diff --git a/source/projects/karma_tilde/karma.h b/source/projects/karma_tilde/karma.h
index 165624e..82e4eba 100644
--- a/source/projects/karma_tilde/karma.h
+++ b/source/projects/karma_tilde/karma.h
@@ -91,18 +91,18 @@ typedef enum {
  * - Computational cost: ~4x linear (4-point interpolation)
  * - Frequency response: Improved high-frequency preservation
  * - Best for: Musical applications, noticeable speed changes
- * - Status: Currently falls back to nearest neighbor (placeholder)
+ * - Implementation: 4-point cubic interpolation
  *
  * INTERP_SPLINE: Highest quality, highest cost
  * - Computational cost: Significantly higher than cubic
  * - Frequency response: Best preservation across spectrum
  * - Best for: Critical listening, large speed variations
- * - Status: Not yet implemented
+ * - Implementation: Catmull-Rom spline interpolation
  */
 typedef enum {
-    INTERP_LINEAR = 0, // Linear interpolation (implemented, default)
-    INTERP_CUBIC = 1,  // Cubic interpolation (placeholder implementation)
-    INTERP_SPLINE = 2  // Spline interpolation (not implemented)
+    INTERP_LINEAR = 0, // Linear interpolation (2-point, default)
+    INTERP_CUBIC = 1,  // Cubic interpolation (4-point)
+    INTERP_SPLINE = 2  // Catmull-Rom spline interpolation (4-point)
 } interp_type_t;
 
 typedef struct t_karma t_karma;
diff --git a/source/projects/karma_tilde/karma~.c b/source/projects/karma_tilde/karma~.c
index a89e864..efd8f7d 100644
--- a/source/projects/karma_tilde/karma~.c
+++ b/source/projects/karma_tilde/karma~.c
@@ -171,13 +171,8 @@ struct t_karma {
     // long    boffset;         // Would allow starting from specific buffer channel (default 0)
     //                          // Decision: Not implemented - current multichannel design sufficient
 
-    long    moduloout;          // RESERVED: Modulo playback channel outputs
-                                // Would cycle through available output channels
-                                // Decision: Not implemented - conflicts with MC signal routing
-
-    long    islooped;           // Global looping enable/disable flag
-                                // 0 = looping disabled, 1 = looping enabled (default)
-                                // Note: Currently not implemented - would require extensive state machine changes
+    // REMOVED: moduloout - RESERVED feature never implemented, conflicts with MC signal routing
+    // REMOVED: islooped - Never implemented, would require extensive state machine changes
 
     long   recordhead;          // record head position in samples
     long   reportlist;          // right list outlet report granularity in ms (!! why is this a long ??)
@@ -236,6 +231,10 @@ static inline void kh_apply_ipoke_interpolation(
     float *b, long pchans, long start_idx, long end_idx,
     double *writeval1, double coeff1, char direction);
 
+static inline void kh_apply_ipoke_interpolation_stereo(
+    float *b, long pchans, long start_idx, long end_idx,
+    double *writeval1, double *writeval2, double coeff1, double coeff2, char direction);
+
 static inline void kh_init_buffer_properties(t_karma *x, t_buffer_obj *buf);
 
 static inline void kh_process_recording_cleanup(
@@ -263,9 +262,12 @@ static inline double kh_perform_playback_interpolation(
     interp_type_t interp, t_bool record);
 
 static inline void kh_process_playfade_state(
-    char *playfadeflag, t_bool *go, t_bool *triginit, t_bool *jumpflag, 
+    char *playfadeflag, t_bool *go, t_bool *triginit, t_bool *jumpflag,
     t_bool *loopdetermine, long *playfade, double *snrfade, t_bool record);
 
+static inline void kh_process_playfade_completion(
+    char *playfadeflag, char *recendmark, t_bool *go, long *playfade);
+
 static inline void kh_process_loop_initialization(
     t_karma *x, float *b, double *accuratehead, char direction,
     long *setloopsize, t_bool *wrapflag, char *recendmark_ptr,
@@ -513,6 +515,7 @@ static inline void kh_process_recording_fade_completion(
             } else {
                 *maxloop = maxhead;
             }
+            break;
         case 2:
             *record = *loopdetermine = 0;
             *triginit = 1;
@@ -543,10 +546,10 @@ static inline void kh_calculate_sync_output(
     }
 }
 
-// Helper function to apply iPoke interpolation over a range
+// Helper function to apply iPoke interpolation over a range (mono)
 static inline void kh_apply_ipoke_interpolation(
     float *b, long pchans, long start_idx, long end_idx,
-    double *writeval1, double coeff1, char direction) 
+    double *writeval1, double coeff1, char direction)
 {
     if (direction > 0) {
         for (long i = start_idx; i < end_idx; i++) {
@@ -561,6 +564,32 @@ static inline void kh_apply_ipoke_interpolation(
     }
 }
 
+// Helper function to apply iPoke interpolation over a range (stereo)
+static inline void kh_apply_ipoke_interpolation_stereo(
+    float *b, long pchans, long start_idx, long end_idx,
+    double *writeval1, double *writeval2, double coeff1, double coeff2, char direction)
+{
+    if (direction > 0) {
+        for (long i = start_idx; i < end_idx; i++) {
+            *writeval1 += coeff1;
+            *writeval2 += coeff2;
+            b[i * pchans] = *writeval1;
+            if (pchans > 1) {
+                b[i * pchans + 1] = *writeval2;
+            }
+        }
+    } else {
+        for (long i = start_idx; i > end_idx; i--) {
+            *writeval1 -= coeff1;
+            *writeval2 -= coeff2;
+            b[i * pchans] = *writeval1;
+            if (pchans > 1) {
+                b[i * pchans + 1] = *writeval2;
+            }
+        }
+    }
+}
+
 // Helper function to initialize buffer properties
 static inline void kh_init_buffer_properties(t_karma *x, t_buffer_obj *buf) {
     x->buffer.bchans   = buffer_getchannelcount(buf);
@@ -735,6 +764,34 @@ static inline void kh_process_playfade_state(
     }
 }
 
+// Helper function to handle playfade completion with recendmark state handling
+static inline void kh_process_playfade_completion(
+    char *playfadeflag, char *recendmark, t_bool *go, long *playfade)
+{
+    if (*playfadeflag == 2) {
+        *recendmark = 4;
+        *go = 1;
+    }
+    *playfadeflag = 0;
+
+    switch (*recendmark) {
+    case 0:
+        /* fallthrough */
+    case 1:
+        *go = 0;
+        break;
+    case 2:
+        /* fallthrough */
+    case 3:
+        *go = 1;
+        *playfade = 0;
+        break;
+    case 4:
+        *recendmark = 0;
+        break;
+    }
+}
+
 // Helper function to handle loop initialization and calculation
 static inline void kh_process_loop_initialization(
     t_karma *x, float *b, double *accuratehead, char direction,
@@ -1222,7 +1279,6 @@ void* karma_new(t_symbol* s, short argc, t_atom* argv)
         x->audio.overdubprev = 1.0;
         x->audio.overdubamp = 1.0;
         x->speedfloat = 1.0;
-        x->islooped = 1;
 
         x->fade.snrtype = SWITCHRAMP_SINE_IN;
         x->audio.interpflag = INTERP_CUBIC;
@@ -2713,53 +2769,17 @@ void karma_mono_perform(
                 playhead = trunc(accuratehead);
 
                 if (globalramp) {
-                    if (playfade < globalramp) // realtime ramps for play on/off
-                    {
+                    if (playfade < globalramp) { // realtime ramps for play on/off
                         playfade++;
-                        if (playfadeflag) {
-                            if (playfade >= globalramp) {
-                                if (playfadeflag == 2) {
-                                    recendmark = 4;
-                                    go = 1;
-                                }
-                                playfadeflag = 0;
-                                switch (recendmark) {
-                                case 0:
-                                case 1:
-                                    go = 0;
-                                    break;
-                                case 2:
-                                case 3:
-                                    go = 1;
-                                    playfade = 0;
-                                    break;
-                                case 4:
-                                    recendmark = 0;
-                                    break;
-                                }
-                            }
+                        if (playfadeflag && (playfade >= globalramp)) {
+                            kh_process_playfade_completion(
+                                &playfadeflag, &recendmark, &go, &playfade);
                         }
                     }
                 } else {
                     if (playfadeflag) {
-                        if (playfadeflag == 2) {
-                            recendmark = 4;
-                            go = 1;
-                        }
-                        playfadeflag = 0;
-                        switch (recendmark) {
-                        case 0:
-                        case 1:
-                            go = 0;
-                            break;
-                        case 2:
-                        case 3:
-                            go = 1;
-                            break;
-                        case 4:
-                            recendmark = 0;
-                            break;
-                        }
+                        kh_process_playfade_completion(
+                            &playfadeflag, &recendmark, &go, &playfade);
                     }
                 }
             }
@@ -3133,53 +3153,17 @@ void karma_stereo_perform(
                 playhead = trunc(accuratehead);
 
                 if (globalramp) {
-                    if (playfade < globalramp) // realtime ramps for play on/off
-                    {
+                    if (playfade < globalramp) { // realtime ramps for play on/off
                         playfade++;
-                        if (playfadeflag) {
-                            if (playfade >= globalramp) {
-                                if (playfadeflag == 2) {
-                                    recendmark = 4;
-                                    go = 1;
-                                }
-                                playfadeflag = 0;
-                                switch (recendmark) {
-                                case 0:
-                                case 1:
-                                    go = 0;
-                                    break;
-                                case 2:
-                                case 3:
-                                    go = 1;
-                                    playfade = 0;
-                                    break;
-                                case 4:
-                                    recendmark = 0;
-                                    break;
-                                }
-                            }
+                        if (playfadeflag && (playfade >= globalramp)) {
+                            kh_process_playfade_completion(
+                                &playfadeflag, &recendmark, &go, &playfade);
                         }
                     }
                 } else {
                     if (playfadeflag) {
-                        if (playfadeflag == 2) {
-                            recendmark = 4;
-                            go = 1;
-                        }
-                        playfadeflag = 0;
-                        switch (recendmark) {
-                        case 0:
-                        case 1:
-                            go = 0;
-                            break;
-                        case 2:
-                        case 3:
-                            go = 1;
-                            break;
-                        case 4:
-                            recendmark = 0;
-                            break;
-                        }
+                        kh_process_playfade_completion(
+                            &playfadeflag, &recendmark, &go, &playfade);
                     }
                 }
             }
@@ -4006,95 +3990,81 @@ static inline void kh_process_initial_loop_ipoke_recording(
 
         if (direction != directionorig) {
             if (directionorig >= 0) {
+                // Forward original direction: wraps between 0 and maxhead
                 if (recplaydif > 0) {
                     if (recplaydif > (maxhead * 0.5)) {
+                        // Wraparound case: backward through 0, then forward from maxhead
                         recplaydif -= maxhead;
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead - 1); i >= 0; i--) {
-                            *writeval1 -= coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead - 1, -1, writeval1, coeff1, -1);
                         kh_apply_ipoke_interpolation(
                             b, pchans, maxhead, playhead, writeval1, coeff1, -1);
                     } else {
+                        // Regular forward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead + 1); i < playhead; i++) {
-                            *writeval1 += coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead + 1, playhead, writeval1, coeff1, 1);
                     }
                 } else {
                     if ((-recplaydif) > (maxhead * 0.5)) {
+                        // Wraparound case: forward to maxhead+1, then forward from 0
                         recplaydif += maxhead;
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead + 1); i < (maxhead + 1); i++) {
-                            *writeval1 += coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
-                        for (i = 0; i < playhead; i++) {
-                            *writeval1 += coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead + 1, maxhead + 1, writeval1, coeff1, 1);
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, 0, playhead, writeval1, coeff1, 1);
                     } else {
+                        // Regular backward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead - 1); i > playhead; i--) {
-                            *writeval1 -= coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead - 1, playhead, writeval1, coeff1, -1);
                     }
                 }
             } else {
+                // Reverse original direction: wraps between maxhead and frames-1
                 if (recplaydif > 0) {
-                    if (recplaydif > (((frames - 1) - (maxhead)) * 0.5)) {
-                        recplaydif -= ((frames - 1) - (maxhead));
+                    if (recplaydif > (((frames - 1) - maxhead) * 0.5)) {
+                        // Wraparound case: backward to maxhead, then backward from frames-1
+                        recplaydif -= ((frames - 1) - maxhead);
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead - 1); i >= maxhead; i--) {
-                            *writeval1 -= coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
-                        for (i = (frames - 1); i > playhead; i--) {
-                            *writeval1 -= coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead - 1, maxhead - 1, writeval1, coeff1, -1);
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, frames - 1, playhead, writeval1, coeff1, -1);
                     } else {
+                        // Regular forward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead + 1); i < playhead; i++) {
-                            *writeval1 += coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead + 1, playhead, writeval1, coeff1, 1);
                     }
                 } else {
-                    if ((-recplaydif) > (((frames - 1) - (maxhead)) * 0.5)) {
-                        recplaydif += ((frames - 1) - (maxhead));
+                    if ((-recplaydif) > (((frames - 1) - maxhead) * 0.5)) {
+                        // Wraparound case: forward to frames, then forward from maxhead
+                        recplaydif += ((frames - 1) - maxhead);
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead + 1); i < frames; i++) {
-                            *writeval1 += coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead + 1, frames, writeval1, coeff1, 1);
                         kh_apply_ipoke_interpolation(
                             b, pchans, maxhead, playhead, writeval1, coeff1, 1);
                     } else {
+                        // Regular backward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
-                        for (i = (*recordhead - 1); i > playhead; i--) {
-                            *writeval1 -= coeff1;
-                            b[i * pchans] = *writeval1;
-                        }
+                        kh_apply_ipoke_interpolation(
+                            b, pchans, *recordhead - 1, playhead, writeval1, coeff1, -1);
                     }
                 }
             }
         } else {
+            // Same direction: simple interpolation
+            coeff1 = (recin1 - *writeval1) / recplaydif;
             if (recplaydif > 0) {
-                coeff1 = (recin1 - *writeval1) / recplaydif;
-                for (i = (*recordhead + 1); i < playhead; i++) {
-                    *writeval1 += coeff1;
-                    b[i * pchans] = *writeval1;
-                }
+                kh_apply_ipoke_interpolation(
+                    b, pchans, *recordhead + 1, playhead, writeval1, coeff1, 1);
             } else {
-                coeff1 = (recin1 - *writeval1) / recplaydif;
-                for (i = (*recordhead - 1); i > playhead; i--) {
-                    *writeval1 -= coeff1;
-                    b[i * pchans] = *writeval1;
-                }
+                kh_apply_ipoke_interpolation(
+                    b, pchans, *recordhead - 1, playhead, writeval1, coeff1, -1);
             }
         }
         *writeval1 = recin1;
@@ -4207,14 +4177,34 @@ static inline double kh_process_audio_interpolation(
     if (!record) { // if recording do linear-interp else...
         switch (interp) {
         case INTERP_CUBIC:
-            // TODO: Implement proper 4-point cubic interpolation
-            // Currently falls back to nearest neighbor for performance
-            output = (double)b[playhead * pchans];
+            // 4-point cubic interpolation
+            // Note: Assumes buffer has sufficient samples before/after playhead
+            if (frac > 0.0) {
+                output = kh_cubic_interp(
+                    frac,
+                    (double)b[(playhead - 1) * pchans], // w
+                    (double)b[playhead * pchans],       // x
+                    (double)b[(playhead + 1) * pchans], // y
+                    (double)b[(playhead + 2) * pchans]  // z
+                );
+            } else {
+                output = (double)b[playhead * pchans];
+            }
             break;
         case INTERP_SPLINE:
-            // TODO: Implement spline interpolation
-            // Currently falls back to nearest neighbor
-            output = (double)b[playhead * pchans];
+            // Catmull-Rom spline interpolation
+            // Note: Assumes buffer has sufficient samples before/after playhead
+            if (frac > 0.0) {
+                output = kh_spline_interp(
+                    frac,
+                    (double)b[(playhead - 1) * pchans], // w
+                    (double)b[playhead * pchans],       // x
+                    (double)b[(playhead + 1) * pchans], // y
+                    (double)b[(playhead + 2) * pchans]  // z
+                );
+            } else {
+                output = (double)b[playhead * pchans];
+            }
             break;
         default: // INTERP_LINEAR
             if (frac > 0.0) {
@@ -4324,165 +4314,90 @@ static inline void kh_process_initial_loop_ipoke_recording_stereo(
 
         if (direction != directionorig) {
             if (directionorig >= 0) {
+                // Forward original direction: wraps between 0 and maxhead
                 if (recplaydif > 0) {
                     if (recplaydif > (maxhead * 0.5)) {
+                        // Wraparound case: backward through 0, then backward from maxhead
                         recplaydif -= maxhead;
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead - 1); i >= 0; i--) {
-                            *writeval1 -= coeff1;
-                            *writeval2 -= coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
-                        for (i = maxhead; i > playhead; i--) {
-                            *writeval1 -= coeff1;
-                            *writeval2 -= coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead - 1, -1, writeval1, writeval2, coeff1, coeff2, -1);
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, maxhead, playhead, writeval1, writeval2, coeff1, coeff2, -1);
                     } else {
+                        // Regular forward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead + 1); i < playhead; i++) {
-                            *writeval1 += coeff1;
-                            *writeval2 += coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead + 1, playhead, writeval1, writeval2, coeff1, coeff2, 1);
                     }
                 } else {
                     if ((-recplaydif) > (maxhead * 0.5)) {
+                        // Wraparound case: forward to maxhead+1, then forward from 0
                         recplaydif += maxhead;
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead + 1); i < (maxhead + 1); i++) {
-                            *writeval1 += coeff1;
-                            *writeval2 += coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
-                        for (i = 0; i < playhead; i++) {
-                            *writeval1 += coeff1;
-                            *writeval2 += coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead + 1, maxhead + 1, writeval1, writeval2, coeff1, coeff2, 1);
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, 0, playhead, writeval1, writeval2, coeff1, coeff2, 1);
                     } else {
+                        // Regular backward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead - 1); i > playhead; i--) {
-                            *writeval1 -= coeff1;
-                            *writeval2 -= coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead - 1, playhead, writeval1, writeval2, coeff1, coeff2, -1);
                     }
                 }
             } else {
+                // Reverse original direction: wraps between maxhead and frames-1
                 if (recplaydif > 0) {
-                    if (recplaydif > (((frames - 1) - (maxhead)) * 0.5)) {
-                        recplaydif -= ((frames - 1) - (maxhead));
+                    if (recplaydif > (((frames - 1) - maxhead) * 0.5)) {
+                        // Wraparound case: backward to maxhead, then backward from frames-1
+                        recplaydif -= ((frames - 1) - maxhead);
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead - 1); i >= maxhead; i--) {
-                            *writeval1 -= coeff1;
-                            *writeval2 -= coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
-                        for (i = (frames - 1); i > playhead; i--) {
-                            *writeval1 -= coeff1;
-                            *writeval2 -= coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead - 1, maxhead - 1, writeval1, writeval2, coeff1, coeff2, -1);
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, frames - 1, playhead, writeval1, writeval2, coeff1, coeff2, -1);
                     } else {
+                        // Regular forward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead + 1); i < playhead; i++) {
-                            *writeval1 += coeff1;
-                            *writeval2 += coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead + 1, playhead, writeval1, writeval2, coeff1, coeff2, 1);
                     }
                 } else {
-                    if ((-recplaydif) > (((frames - 1) - (maxhead)) * 0.5)) {
-                        recplaydif += ((frames - 1) - (maxhead));
+                    if ((-recplaydif) > (((frames - 1) - maxhead) * 0.5)) {
+                        // Wraparound case: forward to frames, then forward from maxhead
+                        recplaydif += ((frames - 1) - maxhead);
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead + 1); i < frames; i++) {
-                            *writeval1 += coeff1;
-                            *writeval2 += coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
-                        for (i = maxhead; i > playhead; i--) {
-                            *writeval1 += coeff1;
-                            *writeval2 += coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead + 1, frames, writeval1, writeval2, coeff1, coeff2, 1);
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, maxhead, playhead, writeval1, writeval2, coeff1, coeff2, 1);
                     } else {
+                        // Regular backward case
                         coeff1 = (recin1 - *writeval1) / recplaydif;
                         coeff2 = (recin2 - *writeval2) / recplaydif;
-                        for (i = (*recordhead - 1); i > playhead; i--) {
-                            *writeval1 -= coeff1;
-                            *writeval2 -= coeff2;
-                            b[i * pchans] = *writeval1;
-                            if (pchans > 1) {
-                                b[i * pchans + 1] = *writeval2;
-                            }
-                        }
+                        kh_apply_ipoke_interpolation_stereo(
+                            b, pchans, *recordhead - 1, playhead, writeval1, writeval2, coeff1, coeff2, -1);
                     }
                 }
             }
         } else {
-            if (recplaydif > 0) { // linear-interpolation for speed > 1x
-                coeff1 = (recin1 - *writeval1) / recplaydif;
-                coeff2 = (recin2 - *writeval2) / recplaydif;
-                for (i = *recordhead + 1; i < playhead; i++) {
-                    *writeval1 += coeff1;
-                    *writeval2 += coeff2;
-                    b[i * pchans] = *writeval1;
-                    if (pchans > 1) {
-                        b[i * pchans + 1] = *writeval2;
-                    }
-                }
+            // Same direction: simple interpolation
+            coeff1 = (recin1 - *writeval1) / recplaydif;
+            coeff2 = (recin2 - *writeval2) / recplaydif;
+            if (recplaydif > 0) {
+                kh_apply_ipoke_interpolation_stereo(
+                    b, pchans, *recordhead + 1, playhead, writeval1, writeval2, coeff1, coeff2, 1);
             } else {
-                coeff1 = (recin1 - *writeval1) / recplaydif;
-                coeff2 = (recin2 - *writeval2) / recplaydif;
-                for (i = *recordhead - 1; i > playhead; i--) {
-                    *writeval1 -= coeff1;
-                    *writeval2 -= coeff2;
-                    b[i * pchans] = *writeval1;
-                    if (pchans > 1) {
-                        b[i * pchans + 1] = *writeval2;
-                    }
-                }
+                kh_apply_ipoke_interpolation_stereo(
+                    b, pchans, *recordhead - 1, playhead, writeval1, writeval2, coeff1, coeff2, -1);
             }
         }
         *writeval1 = recin1;
